#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
#include <windows.h>
#endif

#ifdef _MSC_VER
#   pragma warning( disable : 4996 )
#endif


#ifdef __GNUC__
	//
	#include <fcntl.h>
	#include <sys/mman.h>
	#include <sys/stat.h>
	#include <sys/time.h>
	#include <sys/types.h>
	#include <time.h>
	#include <unistd.h>
	#include <sys/unistd.h>
	//
	#define __stdcall
	//
#endif


#include "Vlong_Gp.h"
#include "rng.h"
#include "rsaimpl.h"

void print_hex_str(const unsigned char *strHex, unsigned int uLenHex, char *strRes);
void print_hex(const unsigned char *strHex, unsigned int uLenHex);
void print_vlong(PTVlong pvl);
void print_vlong_LE(PTVlong pvl);

void test_rsa_512b();
void test_rsa_1024b();
void test_rsa_2048b();

void test_rsa_quintuple_1024b();
void test_rsa_generate_kp_Nb(int NumTests, unsigned int Nbits);
void test_rsa_generate_kp_sign_verify_Nb(unsigned int Nbits);

void test_generate_prime_512();

void test_probable_prime_512();
//
void test_raw_mul_reduction();
//
int GetTickCountMy();//time in ms
//
//int iMemVlongAlloc = 0;
//printf("\n MemVlongAlloc = %d bytes\n",iMemVlongAlloc);
//
//
int main(int argc, char *argv[])
{
	#ifdef _MSC_VER
	SetProcessAffinityMask(GetCurrentProcess(),0x01);
	#endif
	//
	rngInit(0,0);
	//
	//test_raw_mul_reduction();
	//
	//test_rsa_512b();
	//
	//test_rsa_1024b();
	//
	//test_rsa_2048b();
	//
	//test_probable_prime_512();
	//
	//test_generate_prime_512();
	//
	//test_rsa_quintuple_1024b();
	//
	test_rsa_generate_kp_Nb(100, 1024);
	//
	//test_rsa_generate_kp_sign_verify_Nb(1*1024);
	//
	return 0;
}

int test_rsa(PTVlong pN,PTVlong pd,PTVlong pe,PTVlong pmes);

void test_rsa_2048b()
{
// P = DFC10E6B779F8956E1CD13DA7A46404E7166C5D61C4A4C5D510D3417863F6C0A876706BA6C520596DB72BCF1D2CB0504A00F3E128737BD7F349DFC4AF5B5923C4142961EF5C7CBE8F850150A67C7973F3D4C55BD16C89F366CFFE73667870381A8785A8B18DC0C7DF1C233F956F9DDABBA9A0DA1F42DE0442C4CBB70E3A84F9F
// Q = C53B9B5D6C4A852C5CBDA69BC650E8293A92040343D0AC05DC2634B5EEDCA96C8D9E9625F914F6C3E739FCD382EB58C563535197E531CD5A138B9E6469B10966A6BFB9D07F3EB55493C59560E4A9ED91C8CE81A444AC6903CF0E1F6FFD062AE9954FCAA63EE2E3931C59E320E1E5776C4CB0755E4A5E5AD8C7D93EF99C4692BF
// N = AC63A962915639362428AFD44D055D278453B6BC247A651E1A2FF6F3063AC2FD09FAA7D75A89809CAB1E109ECC0D4A77ADD6E8107C48A7F7C9FF6E28583EE80998070AD0B2EBE8A9E7946A6257CD06F38871CA9371C312CDAEB567B614D286C7E9BF91CA33C1EE8E620A116B50B005151055AB65B9AAE6605D5568F5AA3F625F0D29CD1EE2FAABC46E9EC5A0764AB07C343D2F6090139028A610D37FCFA4754CFF199611B8D90961FC2D4C9F611CDF7B2924A6439FDE37443A04E901BD15156201B03CFE6F2F766D4D1C4DB7DC70F61D1FDC0DB777DBCB9CE28283132F16C88E14C18482A2F8A1BF48BC5227166C643D7A5B1791F9D79EFD2483FF41817615A1
// e = 010001
// dP = 74F125642D6508168C74EE4765588A0B75614D4C96048EDCC69BABFA0F83DE27B294BA037CD1717262C718D11A6658FD0DDA698AAD7908650F4EF2A90ABA16EFBEFBDA11DC4ACBDBBACBBFF36C41F85E68DF18807703EB923A6D949DEE85B5E371F554FD15C50C1256E434DDC0035F437D873E50C299A77879DEB0A8539387E9
// dQ = 7DE6E5EF86102FE0B8B6CBA306BE60E4E8A18AF43696FF28A276B5112A102C0AC28068628714EDCCF24E9EE8B9DAD808F0B5A011315A5036DEE13253F0EFF50B55087069FAC021EA82860F2C11EBB35E6B6BFF6FC7F2B2FA9E72EA7887712775823DB423D962E658E33131FEAC94D95E05BA62C1B50174468B944F51F1834F6B
	TVlong N,d,e,mes,P,Q;
	vl_init(&N);vl_init(&P);vl_init(&Q);
	vl_init(&d);
	vl_init(&e);
	vl_init(&mes);
	unsigned char str_N[] = {
	0xAC, 0x63, 0xA9, 0x62, 0x91, 0x56, 0x39, 0x36, 0x24, 0x28, 0xAF, 0xD4, 0x4D, 0x05, 0x5D, 0x27, 
	0x84, 0x53, 0xB6, 0xBC, 0x24, 0x7A, 0x65, 0x1E, 0x1A, 0x2F, 0xF6, 0xF3, 0x06, 0x3A, 0xC2, 0xFD, 
	0x09, 0xFA, 0xA7, 0xD7, 0x5A, 0x89, 0x80, 0x9C, 0xAB, 0x1E, 0x10, 0x9E, 0xCC, 0x0D, 0x4A, 0x77,
	0xAD, 0xD6, 0xE8, 0x10, 0x7C, 0x48, 0xA7, 0xF7, 0xC9, 0xFF, 0x6E, 0x28, 0x58, 0x3E, 0xE8, 0x09,
	0x98, 0x07, 0x0A, 0xD0, 0xB2, 0xEB, 0xE8, 0xA9, 0xE7, 0x94, 0x6A, 0x62, 0x57, 0xCD, 0x06, 0xF3,
	0x88, 0x71, 0xCA, 0x93, 0x71, 0xC3, 0x12, 0xCD, 0xAE, 0xB5, 0x67, 0xB6, 0x14, 0xD2, 0x86, 0xC7,
	0xE9, 0xBF, 0x91, 0xCA, 0x33, 0xC1, 0xEE, 0x8E, 0x62, 0x0A, 0x11, 0x6B, 0x50, 0xB0, 0x05, 0x15,
	0x10, 0x55, 0xAB, 0x65, 0xB9, 0xAA, 0xE6, 0x60, 0x5D, 0x55, 0x68, 0xF5, 0xAA, 0x3F, 0x62, 0x5F,
	0x0D, 0x29, 0xCD, 0x1E, 0xE2, 0xFA, 0xAB, 0xC4, 0x6E, 0x9E, 0xC5, 0xA0, 0x76, 0x4A, 0xB0, 0x7C,
	0x34, 0x3D, 0x2F, 0x60, 0x90, 0x13, 0x90, 0x28, 0xA6, 0x10, 0xD3, 0x7F, 0xCF, 0xA4, 0x75, 0x4C,
	0xFF, 0x19, 0x96, 0x11, 0xB8, 0xD9, 0x09, 0x61, 0xFC, 0x2D, 0x4C, 0x9F, 0x61, 0x1C, 0xDF, 0x7B,
	0x29, 0x24, 0xA6, 0x43, 0x9F, 0xDE, 0x37, 0x44, 0x3A, 0x04, 0xE9, 0x01, 0xBD, 0x15, 0x15, 0x62,
	0x01, 0xB0, 0x3C, 0xFE, 0x6F, 0x2F, 0x76, 0x6D, 0x4D, 0x1C, 0x4D, 0xB7, 0xDC, 0x70, 0xF6, 0x1D,
	0x1F, 0xDC, 0x0D, 0xB7, 0x77, 0xDB, 0xCB, 0x9C, 0xE2, 0x82, 0x83, 0x13, 0x2F, 0x16, 0xC8, 0x8E,
	0x14, 0xC1, 0x84, 0x82, 0xA2, 0xF8, 0xA1, 0xBF, 0x48, 0xBC, 0x52, 0x27, 0x16, 0x6C, 0x64, 0x3D,
	0x7A, 0x5B, 0x17, 0x91, 0xF9, 0xD7, 0x9E, 0xFD, 0x24, 0x83, 0xFF, 0x41, 0x81, 0x76, 0x15, 0xA1
	};
	unsigned char str_d[] = {
	0x01, 0x00, 0x01
	};
	unsigned char str_P[] = {
	0xDF, 0xC1, 0x0E, 0x6B, 0x77, 0x9F, 0x89, 0x56, 0xE1, 0xCD, 0x13, 0xDA, 0x7A, 0x46, 0x40, 0x4E,
	0x71, 0x66, 0xC5, 0xD6, 0x1C, 0x4A, 0x4C, 0x5D, 0x51, 0x0D, 0x34, 0x17, 0x86, 0x3F, 0x6C, 0x0A,
	0x87, 0x67, 0x06, 0xBA, 0x6C, 0x52, 0x05, 0x96, 0xDB, 0x72, 0xBC, 0xF1, 0xD2, 0xCB, 0x05, 0x04,
	0xA0, 0x0F, 0x3E, 0x12, 0x87, 0x37, 0xBD, 0x7F, 0x34, 0x9D, 0xFC, 0x4A, 0xF5, 0xB5, 0x92, 0x3C,
	0x41, 0x42, 0x96, 0x1E, 0xF5, 0xC7, 0xCB, 0xE8, 0xF8, 0x50, 0x15, 0x0A, 0x67, 0xC7, 0x97, 0x3F,
	0x3D, 0x4C, 0x55, 0xBD, 0x16, 0xC8, 0x9F, 0x36, 0x6C, 0xFF, 0xE7, 0x36, 0x67, 0x87, 0x03, 0x81,
	0xA8, 0x78, 0x5A, 0x8B, 0x18, 0xDC, 0x0C, 0x7D, 0xF1, 0xC2, 0x33, 0xF9, 0x56, 0xF9, 0xDD, 0xAB,
	0xBA, 0x9A, 0x0D, 0xA1, 0xF4, 0x2D, 0xE0, 0x44, 0x2C, 0x4C, 0xBB, 0x70, 0xE3, 0xA8, 0x4F, 0x9F
	};
	unsigned char str_Q[] = {
	0xC5, 0x3B, 0x9B, 0x5D, 0x6C, 0x4A, 0x85, 0x2C, 0x5C, 0xBD, 0xA6, 0x9B, 0xC6, 0x50, 0xE8, 0x29,
	0x3A, 0x92, 0x04, 0x03, 0x43, 0xD0, 0xAC, 0x05, 0xDC, 0x26, 0x34, 0xB5, 0xEE, 0xDC, 0xA9, 0x6C,
	0x8D, 0x9E, 0x96, 0x25, 0xF9, 0x14, 0xF6, 0xC3, 0xE7, 0x39, 0xFC, 0xD3, 0x82, 0xEB, 0x58, 0xC5,
	0x63, 0x53, 0x51, 0x97, 0xE5, 0x31, 0xCD, 0x5A, 0x13, 0x8B, 0x9E, 0x64, 0x69, 0xB1, 0x09, 0x66,
	0xA6, 0xBF, 0xB9, 0xD0, 0x7F, 0x3E, 0xB5, 0x54, 0x93, 0xC5, 0x95, 0x60, 0xE4, 0xA9, 0xED, 0x91,
	0xC8, 0xCE, 0x81, 0xA4, 0x44, 0xAC, 0x69, 0x03, 0xCF, 0x0E, 0x1F, 0x6F, 0xFD, 0x06, 0x2A, 0xE9,
	0x95, 0x4F, 0xCA, 0xA6, 0x3E, 0xE2, 0xE3, 0x93, 0x1C, 0x59, 0xE3, 0x20, 0xE1, 0xE5, 0x77, 0x6C,
	0x4C, 0xB0, 0x75, 0x5E, 0x4A, 0x5E, 0x5A, 0xD8, 0xC7, 0xD9, 0x3E, 0xF9, 0x9C, 0x46, 0x92, 0xBF
	};
	unsigned char str_mes[] = {
	 0x1C, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC,
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC
	};
	//
	//vl_set_uchar_BE(&N,str_N,sizeof(str_N));
	vl_set_uchar_BE(&P,str_P,sizeof(str_P));
	vl_set_uchar_BE(&Q,str_Q,sizeof(str_Q));
	vl_set_uchar_BE(&d,str_d,sizeof(str_d));
	vl_set_uchar_BE(&mes,str_mes,sizeof(str_mes));
	//e = d^-1 mod((P-1)*(Q-1))
	vl_dec(&P);
	vl_dec(&Q);
	vl_mule(&N,&Q,&P);//N = (P-1)*(Q-1)
	vl_modinv_all(&e,&d,&N);
	//
	vl_set_uchar_BE(&N,str_N,sizeof(str_N));
	//
	test_rsa(&N,&d,&e,&mes);
	//
	vl_delete(&N);vl_delete(&P);vl_delete(&Q);
	vl_delete(&d);
	vl_delete(&e);
	vl_delete(&mes);
}

void test_rsa_1024b()
{
	//Основание = P*Q (128 байт):
	//A2B88B11C5095E4730A18C3EE55EB1D9379222A79802BD842BBE8200334EFED6713AD24726AD4E04F1E4985E96B2ADE231775A30973B8AC42204B28C48772FA660E068157D6352D802363141FCE7EE70F52A2FE52B214169D60687488D90E7E6186C47B9F2BEC1960C2A99AA0CEADD473401C565BA00029D0BA89D4289D8D881
	//Ключ 1 (3 байт):
	//010001
	//Ключ 2 (128 байт):
	//321A265FE34E5E24075A46877B326C0A58ECFB14A55E7AA1FEA21AFF1ACD40F4204B1F41DF2BCF7100560580626043DFF8A12A38F9E7D073519226B3C10049C02F3DF654A2013B5B8DAF42D0BBBDE95B6B7C764B893A8B5A03FD180F529DEF51568C1238F53E1229BF6BB0115B234AED916040325936632C8AF4FB7DDBE3373D

	TVlong N,d,e,mes;
	vl_init(&N);
	vl_init(&d);
	vl_init(&e);
	vl_init(&mes);
	unsigned char str_N[] = {
	0xA2, 0xB8, 0x8B, 0x11, 0xC5, 0x09, 0x5E, 0x47, 0x30, 0xA1, 0x8C, 0x3E, 0xE5, 0x5E, 0xB1, 0xD9,
	0x37, 0x92, 0x22, 0xA7, 0x98, 0x02, 0xBD, 0x84, 0x2B, 0xBE, 0x82, 0x00, 0x33, 0x4E, 0xFE, 0xD6,
	0x71, 0x3A, 0xD2, 0x47, 0x26, 0xAD, 0x4E, 0x04, 0xF1, 0xE4, 0x98, 0x5E, 0x96, 0xB2, 0xAD, 0xE2,
	0x31, 0x77, 0x5A, 0x30, 0x97, 0x3B, 0x8A, 0xC4, 0x22, 0x04, 0xB2, 0x8C, 0x48, 0x77, 0x2F, 0xA6,
	0x60, 0xE0, 0x68, 0x15, 0x7D, 0x63, 0x52, 0xD8, 0x02, 0x36, 0x31, 0x41, 0xFC, 0xE7, 0xEE, 0x70,
	0xF5, 0x2A, 0x2F, 0xE5, 0x2B, 0x21, 0x41, 0x69, 0xD6, 0x06, 0x87, 0x48, 0x8D, 0x90, 0xE7, 0xE6,
	0x18, 0x6C, 0x47, 0xB9, 0xF2, 0xBE, 0xC1, 0x96, 0x0C, 0x2A, 0x99, 0xAA, 0x0C, 0xEA, 0xDD, 0x47,
	0x34, 0x01, 0xC5, 0x65, 0xBA, 0x00, 0x02, 0x9D, 0x0B, 0xA8, 0x9D, 0x42, 0x89, 0xD8, 0xD8, 0x81
	};
	unsigned char str_d[] = {
	0x01, 0x00, 0x01
	};
	unsigned char str_e[] = {
	0x32, 0x1A, 0x26, 0x5F, 0xE3, 0x4E, 0x5E, 0x24, 0x07, 0x5A, 0x46, 0x87, 0x7B, 0x32, 0x6C, 0x0A,
	0x58, 0xEC, 0xFB, 0x14, 0xA5, 0x5E, 0x7A, 0xA1, 0xFE, 0xA2, 0x1A, 0xFF, 0x1A, 0xCD, 0x40, 0xF4,
	0x20, 0x4B, 0x1F, 0x41, 0xDF, 0x2B, 0xCF, 0x71, 0x00, 0x56, 0x05, 0x80, 0x62, 0x60, 0x43, 0xDF,
	0xF8, 0xA1, 0x2A, 0x38, 0xF9, 0xE7, 0xD0, 0x73, 0x51, 0x92, 0x26, 0xB3, 0xC1, 0x00, 0x49, 0xC0,
	0x2F, 0x3D, 0xF6, 0x54, 0xA2, 0x01, 0x3B, 0x5B, 0x8D, 0xAF, 0x42, 0xD0, 0xBB, 0xBD, 0xE9, 0x5B,
	0x6B, 0x7C, 0x76, 0x4B, 0x89, 0x3A, 0x8B, 0x5A, 0x03, 0xFD, 0x18, 0x0F, 0x52, 0x9D, 0xEF, 0x51,
	0x56, 0x8C, 0x12, 0x38, 0xF5, 0x3E, 0x12, 0x29, 0xBF, 0x6B, 0xB0, 0x11, 0x5B, 0x23, 0x4A, 0xED,
	0x91, 0x60, 0x40, 0x32, 0x59, 0x36, 0x63, 0x2C, 0x8A, 0xF4, 0xFB, 0x7D, 0xDB, 0xE3, 0x37, 0x3D
	};
	unsigned char str_mes[] = {
	 0x1C, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC
	};
	//
	vl_set_uchar_BE(&N,str_N,sizeof(str_N));
	vl_set_uchar_BE(&d,str_d,sizeof(str_d));
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_set_uchar_BE(&mes,str_mes,sizeof(str_mes));
	//
	test_rsa(&N,&d,&e,&mes);
	//
	vl_delete(&N);
	vl_delete(&d);
	vl_delete(&e);
	vl_delete(&mes);
};

void test_rsa_512b()
{
//Основание = P*Q (64 байт):
//CBBDDC53BB6AE62CC0347F5439DFA555517A74481244A383E32B538937A4D50CA75AB0F24C318FEC40A20159C83C42D2CEEDCBE6872D2F725E1C0218F0364EC1
//Ключ 1 (3 байт):
//010001
//Ключ 2 (64 байт):
//78EABA4B5B6CAB249E01CA1BC3A92EA77F0ECCDA453545522DCD75EB7701B58A97ED07F4700D5C17FD12607677A9D9EFEA44E6C24294676C0CD8251FC5C97E3D
	TVlong N,d,e,mes;
	vl_init(&N);
	vl_init(&d);
	vl_init(&e);
	vl_init(&mes);
	//
	unsigned char str_N[] = {
	0xCB, 0xBD, 0xDC, 0x53, 0xBB, 0x6A, 0xE6, 0x2C, 0xC0, 0x34, 0x7F, 0x54, 0x39, 0xDF, 0xA5, 0x55,
	0x51, 0x7A, 0x74, 0x48, 0x12, 0x44, 0xA3, 0x83, 0xE3, 0x2B, 0x53, 0x89, 0x37, 0xA4, 0xD5, 0x0C,
	0xA7, 0x5A, 0xB0, 0xF2, 0x4C, 0x31, 0x8F, 0xEC, 0x40, 0xA2, 0x01, 0x59, 0xC8, 0x3C, 0x42, 0xD2,
	0xCE, 0xED, 0xCB, 0xE6, 0x87, 0x2D, 0x2F, 0x72, 0x5E, 0x1C, 0x02, 0x18, 0xF0, 0x36, 0x4E, 0xC1
	};
	unsigned char str_d[] = {
	0x01, 0x00, 0x01
	};
	unsigned char str_e[] = {
	0x78, 0xEA, 0xBA, 0x4B, 0x5B, 0x6C, 0xAB, 0x24, 0x9E, 0x01, 0xCA, 0x1B, 0xC3, 0xA9, 0x2E, 0xA7,
	0x7F, 0x0E, 0xCC, 0xDA, 0x45, 0x35, 0x45, 0x52, 0x2D, 0xCD, 0x75, 0xEB, 0x77, 0x01, 0xB5, 0x8A,
	0x97, 0xED, 0x07, 0xF4, 0x70, 0x0D, 0x5C, 0x17, 0xFD, 0x12, 0x60, 0x76, 0x77, 0xA9, 0xD9, 0xEF,
	0xEA, 0x44, 0xE6, 0xC2, 0x42, 0x94, 0x67, 0x6C, 0x0C, 0xD8, 0x25, 0x1F, 0xC5, 0xC9, 0x7E, 0x3D
	};
	unsigned char str_mes[] = {
	 0x1C, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC
	};
	//
	vl_set_uchar_BE(&N,str_N,sizeof(str_N));
	vl_set_uchar_BE(&d,str_d,sizeof(str_d));
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_set_uchar_BE(&mes,str_mes,sizeof(str_mes));
	//
	test_rsa(&N,&d,&e,&mes);
	//
	vl_delete(&N);
	vl_delete(&d);
	vl_delete(&e);
	vl_delete(&mes);
}

int test_rsa(PTVlong pN,PTVlong pd,PTVlong pe,PTVlong pmes)
{
	int i,Ntimes = 1000;
	TVlong res;
	TMontExp me;
	TBarrettReduction br;
	TQuisquaterReduction qr;

	vl_init(&res);

	printf("\n--- RSA Test ---\n");
	//1
	printf("\n   N = ");
	print_vlong(pN);
	printf("\n   d = ");
	print_vlong(pd);
	printf("\n   e = ");
	print_vlong(pe);
	printf("\n mes = ");
	print_vlong(pmes);

	#ifdef WIN32
	Sleep(1000);
	#endif

	if(vl_bits(pN) > 1024)
		Ntimes = 100;
	//
	printf("\n Key length = %d bits", vl_bits(pN));
	
	// ---- Montgomery modular exponentiation ----
	printf("\n\n --- Montgomery modular exponentiation ");
	
	me_init(&me,pN);

	printf("\nme_modexp(mes^e) = ");
	me_modexp(&res,pmes,pe,&me);
	print_vlong(&res);

	printf("\nme_modexp(res^d) = ");
	me_modexp(pmes,&res,pd,&me);
	print_vlong(pmes);

	//
	int iTstart = GetTickCountMy();
	//
	for(i = 0; i < Ntimes; ++i){
		me_modexp(&res,pmes,pe,&me);
		//vl_copy(&mes,&res);
	}
	printf("\n%d*me_modexp(mes^e) = %d ms", i, GetTickCountMy() - iTstart);
	//printf("\nme_modexp(mes^e) = ");
	//print_vlong(&res);

	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
		me_modexp(pmes,&res,pd,&me);
		//vl_copy(&res,&mes);
	}
	printf("\n%d*me_modexp(res^d) = %d ms", i, GetTickCountMy() - iTstart);
	//printf("\nme_modexp(res^d) = ");
	//print_vlong(pmes);


	//
	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
	 me_delete(&me);
	 me_init(&me,pN);
	}
	printf("\n%d*me_init = %d ms", i, GetTickCountMy() - iTstart);

	// ---- Quisquater Reduction----
	printf("\n\n --- Quisquater Reduction ");

	qr_init(&qr,pN);

	qr_modexp(&res,pmes,pe,&qr);
	printf("\nqr_modexp(mes^e) = ");
	print_vlong(&res);

	qr_modexp(pmes,&res,pd,&qr);
	printf("\nqr_modexp(res^d) = ");
	print_vlong(pmes);

	iTstart = GetTickCountMy();
	for(i = 0; i < Ntimes; ++i){
	 qr_modexp(&res,pmes,pe,&qr);
	}
	printf("\n%d*qr_modexp(mes^e) = %d ms", i, GetTickCountMy() - iTstart);

	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
	 qr_modexp(pmes,&res,pd,&qr);
	}
	printf("\n%d*qr_modexp(res^d) = %d ms", i, GetTickCountMy() - iTstart);

	//
	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
	 qr_delete(&qr);
	 qr_init(&qr,pN);
	}
	printf("\n%d*qr_init = %d ms", i, GetTickCountMy() - iTstart);

	// ---- BarrettReduction ----
	printf("\n\n --- BarrettReduction ");

	br_init(&br,pN);

	br_modexp(&res,pmes,pe,&br);
	printf("\nbr_modexp(mes^e) = ");
	print_vlong(&res);

	br_modexp(pmes,&res,pd,&br);
	printf("\nbr_modexp(res^d) = ");
	print_vlong(pmes);

	iTstart = GetTickCountMy();
	for(i = 0; i < Ntimes; ++i){
	 br_modexp(&res,pmes,pe,&br);
	}
	printf("\n%d*br_modexp(mes^e) = %d ms", i, GetTickCountMy() - iTstart);

	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
	 br_modexp(pmes,&res,pd,&br);
	}
	printf("\n%d*br_modexp(res^d) = %d ms", i, GetTickCountMy() - iTstart);

	//
	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
	 br_delete(&br);
	 br_init(&br,pN);
	}
	printf("\n%d*br_init = %d ms", i, GetTickCountMy() - iTstart);
	
	// --- PKCS#1 rsapq_ep
	TRSAPublicKey rsapk;
	rsapk_init(&rsapk);
	vl_copy(&rsapk.e,pe);
	vl_copy(&rsapk.N,pN);
	
	printf("\n\n --- PKCS#1 rsapq_ep ");

	rsapq_ep(&res,pmes,&rsapk);
	printf("\nrsapq_ep(mes^e) = ");
	print_vlong(&res);
	
	vl_copy(&rsapk.e,pd);
	rsapq_ep(pmes,&res,&rsapk);
	printf("\nrsapq_ep(res^d) = ");
	print_vlong(pmes);

	vl_copy(&rsapk.e,pe);
	iTstart = GetTickCountMy();
	for(i = 0; i < Ntimes; ++i){
		rsapq_ep(&res,pmes,&rsapk);
	}
	printf("\n%d*rsapq_ep(mes^e) = %d ms", i, GetTickCountMy() - iTstart);

	vl_copy(&rsapk.e,pd);
	iTstart = GetTickCountMy();
	for(i = 0; i < 10*Ntimes; ++i){
		rsapq_ep(pmes,&res,&rsapk);
	}
	printf("\n%d*rsapq_ep(res^d) = %d ms", i, GetTickCountMy() - iTstart);
	
	//
	rsapk_delete(&rsapk);
	vl_delete(&res);
	me_delete(&me);
	br_delete(&br);
	qr_delete(&qr);

	printf("\n");
	//
	return 0;
}

//
void test_rsa_quintuple_1024b()
{
//Базовые простые числа(P,Q)
//P (64 байт):
//B446F45A164AC34163FA07FA8F12ABCE2E49742C6E838550D755269F2BFE3F363974D0965BE935A4838D9C284195EF90DEFA2CA8C8E6F880650B0840463F87EB
//Q (64 байт):
//E711C69E27FB87993E60E516E2329E614DD67F8300C44B521462A5130CFD301C883CA286BD9A862C6772009A1951E20ADEEF0A83E935CEB6FE1B7D4CC44D5243
//Ключ 1 (3 байт):
//010001
	TVlong P,Q,N,e,mes,res;
	TRSAPrivateQuintuple rsa_pq;

	unsigned char str_P[] = {
	0xB4, 0x46, 0xF4, 0x5A, 0x16, 0x4A, 0xC3, 0x41, 0x63, 0xFA, 0x07, 0xFA, 0x8F, 0x12, 0xAB, 0xCE,
	0x2E, 0x49, 0x74, 0x2C, 0x6E, 0x83, 0x85, 0x50, 0xD7, 0x55, 0x26, 0x9F, 0x2B, 0xFE, 0x3F, 0x36,
	0x39, 0x74, 0xD0, 0x96, 0x5B, 0xE9, 0x35, 0xA4, 0x83, 0x8D, 0x9C, 0x28, 0x41, 0x95, 0xEF, 0x90,
	0xDE, 0xFA, 0x2C, 0xA8, 0xC8, 0xE6, 0xF8, 0x80, 0x65, 0x0B, 0x08, 0x40, 0x46, 0x3F, 0x87, 0xEB
	};

	unsigned char str_Q[] = {
	0xE7, 0x11, 0xC6, 0x9E, 0x27, 0xFB, 0x87, 0x99, 0x3E, 0x60, 0xE5, 0x16, 0xE2, 0x32, 0x9E, 0x61,
	0x4D, 0xD6, 0x7F, 0x83, 0x00, 0xC4, 0x4B, 0x52, 0x14, 0x62, 0xA5, 0x13, 0x0C, 0xFD, 0x30, 0x1C,
	0x88, 0x3C, 0xA2, 0x86, 0xBD, 0x9A, 0x86, 0x2C, 0x67, 0x72, 0x00, 0x9A, 0x19, 0x51, 0xE2, 0x0A,
	0xDE, 0xEF, 0x0A, 0x83, 0xE9, 0x35, 0xCE, 0xB6, 0xFE, 0x1B, 0x7D, 0x4C, 0xC4, 0x4D, 0x52, 0x43
	};

	unsigned char str_e[] = {
	0x01, 0x00, 0x01
	};
	
	unsigned char str_mes[] = {
	 0x1C, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC
	};
	//
	printf("\n\n--- test_rsa_quintuple_1024b ---\n");

	vl_init(&P);
	vl_init(&Q);
	vl_init(&N);
	vl_init(&e);
	vl_init(&mes);
	vl_init(&res);
	rsapq_init(&rsa_pq);

	vl_set_uchar_BE(&P,str_P,sizeof(str_P));
	vl_set_uchar_BE(&Q,str_Q,sizeof(str_Q));
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_set_uchar_BE(&mes,str_mes,sizeof(str_mes));

	//1
	// N = P*Q
	vl_mule(&N,&P,&Q);
	//
	printf("\n   P = ");
	print_vlong(&P);
	printf("\n   Q = ");
	print_vlong(&Q);
	printf("\nN=P*Q= ");
	print_vlong(&N);
	printf("\n   e = ");
	print_vlong(&e);

	//2
	int i;
	int iTstart = GetTickCountMy();
	for(i=0; i < 1000; ++i){
		rsapq_delete(&rsa_pq);
		rsapq_init(&rsa_pq);
		rsapq_calculate(&rsa_pq,&P,&Q,&e);
		/*
		vl_dec(&P);//P = P - 1
		vl_modinv_all(&dP,&e,&P);//dP = e^(-1) mod (P-1)
		//vl_modinv(&dP,&e,&P);//dP = e^(-1) mod (P-1)
		vl_inc(&P);

		vl_dec(&Q);//Q = Q - 1
		vl_modinv_all(&dQ,&e,&Q);//dQ = e^(-1) mod (Q-1)
		//vl_modinv(&dQ,&e,&Q);//dQ = e^(-1) mod (Q-1)
		vl_inc(&Q);

		if(vl_cf(&P,&Q) < 0){//P < Q
			vl_usub(&Q,&P);
			vl_modinv(&Qinv,&Q,&P);//Qinv = Q^(-1) mod P
			vl_add(&Q,&P);
		}else{
			vl_modinv(&Qinv,&Q,&P);//Qinv = Q^(-1) mod P
		}
		//*/
	}
	printf("\n%d*(dP,dQ,Qinv) = %d ms", i, GetTickCountMy() - iTstart);

	//3
	printf("\n  dP = ");
	print_vlong(&rsa_pq.dP);
	printf("\n  dQ = ");
	print_vlong(&rsa_pq.dQ);
	printf("\nQinv = ");
	print_vlong(&rsa_pq.Qinv);

	//4
	printf("\n\nCheck results:");

	//Qinv*Q = 1 mod P
	vl_mule(&e,&rsa_pq.Qinv,&Q);
	vl_dive(0,&e,&e,&P);//e = (Qinv*Q) % P
	printf("\nQinv*Q mod P = ");
	print_vlong(&e);

	//e*dP = 1 mod (P - 1)
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_dec(&P);//P = P - 1
	vl_mul(&e,&rsa_pq.dP);//e = e*dP
	vl_dive(0,&e,&e,&P);//e = (e*dP) % P-1
	printf("\ne*dP mod P-1 = ");
	print_vlong(&e);

	//e*dQ = 1 mod (Q - 1)
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_dec(&Q);//Q = Q - 1
	vl_mul(&e,&rsa_pq.dQ);//e = e*dQ
	vl_dive(0,&e,&e,&Q);//e = (e*dQ) % Q-1
	printf("\ne*dQ mod Q-1 = ");
	print_vlong(&e);
	
	//
	printf("\n\n --- PKCS#1 rsapq_dp(ep)");
	//
	TRSAPublicKey rsapk;
	rsapk_init(&rsapk);
	
	// rsapq_delete(&rsa_pq);
	// rsapq_init(&rsa_pq);
	// vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	// rsapq_calculate(&rsa_pq,&P,&Q,&e);
	//
	if(1 == rsapq_dp(&res,&mes,&rsa_pq)){
		printf("\n mes = ");
		print_vlong(&mes);
		printf("\n rsapq_dp(mes) = ");
		print_vlong(&res);
	}
	//
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	vl_copy(&rsapk.e,&e);
	vl_copy(&rsapk.N,&N);
	
	if(1 == rsapq_ep(&mes,&res,&rsapk)){
		printf("\n rsapq_ep(res) = ");
		print_vlong(&mes);
	}

	iTstart = GetTickCountMy();
	for(i = 0; i < 1000; ++i){
		//
		rsapk_delete(&rsapk);
		rsapk_init(&rsapk);
		vl_copy(&rsapk.e,&e);
		vl_copy(&rsapk.N,&N);
		//
		rsapq_ep(&mes,&res,&rsapk);
	}
	printf("\n%d*rsapq_ep(res) = %d ms", i, GetTickCountMy() - iTstart);
	
	//
	vl_set_uchar_BE(&P,str_P,sizeof(str_P));
	vl_set_uchar_BE(&Q,str_Q,sizeof(str_Q));
	vl_set_uchar_BE(&e,str_e,sizeof(str_e));
	
	iTstart = GetTickCountMy();
	for(i = 0; i < 1000; ++i){
		//
		rsapq_delete(&rsa_pq);
		rsapq_init(&rsa_pq);
		rsapq_calculate(&rsa_pq,&P,&Q,&e);
		//
		rsapq_dp(&res,&mes,&rsa_pq);
	}
	printf("\n%d*rsapq_dp(mes) = %d ms", i, GetTickCountMy() - iTstart);
	//
	vl_delete(&P);
	vl_delete(&Q);
	vl_delete(&N);
	vl_delete(&e);
	vl_delete(&mes);
	vl_delete(&res);
	rsapq_delete(&rsa_pq);
	rsapk_delete(&rsapk);
}

void test_rsa_generate_kp_Nb(int NumTests, unsigned int Nbits)
{
	TRSAPublicKey PK;
	TRSAPrivateQuintuple PQ;
	printf("\n\n--- test_rsa_generate_kp_%d ---\n", Nbits);
	rsapk_init(&PK);
	rsapq_init(&PQ);
//int rsa_generate_kp(unsigned int bit_len, const PTVlong p_e, PTRSAPublicKey pPK, PTRSAPrivateQuintuple pPQ);
//rsa_generate_kp
	int i, res,num = 0;
	int iTstart = GetTickCountMy();
	for(i = 0; i < NumTests; ++i){
		printf("\n");
		if((res = rsa_generate_kp(Nbits,0,&PK,&PQ)) == 1){
			num += 1;
			printf("\n\n P = ");
			print_vlong(&PQ.P);
			printf("\n Q = ");
			print_vlong(&PQ.Q);
			printf("\n N = ");
			print_vlong(&PK.N);
			printf("\n e = ");
			print_vlong(&PK.e);
			//
			rsapk_clear(&PK);
			rsapq_clear(&PQ);
		}else{
			printf("\n\n Error = %d\n", res);
		}
	}
	printf("\n\n%d*rsa_generate_kp(%d) = %d ms (%d lucky)", i, Nbits, GetTickCountMy() - iTstart, num);

	rsapk_delete(&PK);
	rsapq_delete(&PQ);
}

void test_rsa_generate_kp_sign_verify_Nb(unsigned int Nbits)
{
	TRSAPublicKey PK;
	TRSAPrivateQuintuple PQ;
	TVlong vmes,vmes2,vres;
	//
	printf("\n\n--- test_rsa_generate_kp_sign_verify_Nb%d ---\n\n", Nbits);
	int res,num = 0;
	int iTstart = GetTickCountMy();
	//
	vl_init(&vmes);
	vl_init(&vmes2);
	vl_init(&vres);
	rsapk_init(&PK);
	rsapq_init(&PQ);
	//
	if((res = rsa_generate_kp(Nbits,0,&PK,&PQ)) == 1){
		//
		printf("\n -rsa_generate_kp = %d ms\n", GetTickCountMy() - iTstart);
		printf("\n\n P = ");
		print_vlong(&PQ.P);
		printf("\n Q = ");
		print_vlong(&PQ.Q);
		printf("\n N = ");
		print_vlong(&PK.N);
		printf("\n e = ");
		print_vlong(&PK.e);
		//check rsapq_ep & rsapq_dp
		iTstart = GetTickCountMy();
		if((res = rsapq_calculate(&PQ,&PQ.P,&PQ.Q,&PK.e)) == 1)
		{
			printf("\n -rsapq_calculate = %d ms\n", GetTickCountMy() - iTstart);
			printf("\n dP = ");
			print_vlong(&PQ.dP);
			printf("\n dQ = ");
			print_vlong(&PQ.dQ);
			printf("\nQinv= ");
			print_vlong(&PQ.Qinv);
			//
			num = 0;
			vl_clear(&vmes);
			vl_copy(&vmes,&PK.N);
			vl_dec(&vmes);//vmes = P*Q-1
			//
			iTstart = GetTickCountMy();
			//1 step
			do{
				//printf("\n run rsapq_dp, vmes = ");
				//print_vlong(&vmes);
				if((res = rsapq_dp(&vres,&vmes,&PQ)) != 1){
					printf("\n rsapq_dp error = %d",res);
					break;
				}
				//
				//printf("\n run rsapq_ep, vres = ");
				//print_vlong(&vres);
				if((res = rsapq_ep(&vmes2,&vres,&PK)) != 1){
					printf("\n rsapq_ep error = %d",res);
					break;
				}
				//
				if(vl_cf(&vmes,&vmes2) == 0){
					num += 1;//test ok
				}else{
					//test err
					printf("\n test error!: ");
					printf("\n  vmes  = ");
					print_vlong(&vmes);
					printf("\nvres(ep)= ");
					print_vlong(&vres);
					printf("\n  vmes2 = ");
					print_vlong(&vmes2);
					//
					break;
				}
				//
				vl_shr(&vmes);
				//
				vl_clear(&vres);
				vl_clear(&vmes2);
				//
			}while((vmes.value.n >= 1) || ((vmes.value.n == 1)&&(vmes.value.pa[0] > 1)));
			//2 step
			vl_clear(&vmes);
			vl_set(&vmes,0,2);//vmes = 2
			do{
				//printf("\n run rsapq_dp, vmes = ");
				//print_vlong(&vmes);
				if((res = rsapq_dp(&vres,&vmes,&PQ)) != 1){
					printf("\n rsapq_dp error = %d",res);
					break;
				}
				//
				//printf("\n run rsapq_ep, vres = ");
				//print_vlong(&vres);
				if((res = rsapq_ep(&vmes2,&vres,&PK)) != 1){
					printf("\n rsapq_ep error = %d",res);
					break;
				}
				//
				if(vl_cf(&vmes,&vmes2) == 0){
					num += 1;//test ok
				}else{
					//test err
					printf("\n test error!: ");
					printf("\n  vmes  = ");
					print_vlong(&vmes);
					printf("\nvres(ep)= ");
					print_vlong(&vres);
					printf("\n  vmes2 = ");
					print_vlong(&vmes2);
					//
					break;
				}
				//
				vl_shl(&vmes);
				//
				vl_clear(&vres);
				vl_clear(&vmes2);
				//
			}while(vl_cf(&vmes,&PK.N) < 0);//vmes < PK.N
			//
			printf("\n test proceed %d times...", num);
			//
		}else{
			printf("\n rsapq_calculate error = %d",res);
		}
		//
		rsapk_clear(&PK);
		rsapq_clear(&PQ);
	}else{
		printf("\n rsa_generate_kp error = %d\n", res);
	}
	
	printf("\n test_rsa_generate_kp_sign_verify_Nb(%d) = %d ms\n", Nbits, GetTickCountMy() - iTstart);

	vl_delete(&vmes);
	vl_delete(&vmes2);
	vl_delete(&vres);
	rsapk_delete(&PK);
	rsapq_delete(&PQ);
}


void test_generate_prime_512()
{
	TVlong P;
	int i, lucky = 0;

	
	printf("\n\n--- test_generate_prime_512 ---\n");

	int iTstart = GetTickCountMy();
	for(i = 0; i < 100; ++i){
		vl_init(&P);
		if(1 == generate_prime(&P,512)){
			lucky+=1;
			printf("\n(%02d)prime = ",i);
			print_vlong(&P);
			vl_delete(&P);
		}
	}
	printf("\n%d*generate_prime = %d ms (%d lucky)", i, GetTickCountMy() - iTstart,lucky);

}

void test_probable_prime_512(){
//Базовые простые числа(P,Q)
//P (64 байт):
//B446F45A164AC34163FA07FA8F12ABCE2E49742C6E838550D755269F2BFE3F363974D0965BE935A4838D9C284195EF90DEFA2CA8C8E6F880650B0840463F87EB
//Q (64 байт):
//E711C69E27FB87993E60E516E2329E614DD67F8300C44B521462A5130CFD301C883CA286BD9A862C6772009A1951E20ADEEF0A83E935CEB6FE1B7D4CC44D5243
	unsigned char str_P[] = {
	0xB4, 0x46, 0xF4, 0x5A, 0x16, 0x4A, 0xC3, 0x41, 0x63, 0xFA, 0x07, 0xFA, 0x8F, 0x12, 0xAB, 0xCE, 
	0x2E, 0x49, 0x74, 0x2C, 0x6E, 0x83, 0x85, 0x50, 0xD7, 0x55, 0x26, 0x9F, 0x2B, 0xFE, 0x3F, 0x36, 
	0x39, 0x74, 0xD0, 0x96, 0x5B, 0xE9, 0x35, 0xA4, 0x83, 0x8D, 0x9C, 0x28, 0x41, 0x95, 0xEF, 0x90, 
	0xDE, 0xFA, 0x2C, 0xA8, 0xC8, 0xE6, 0xF8, 0x80, 0x65, 0x0B, 0x08, 0x40, 0x46, 0x3F, 0x87, 0xEB
	};
	unsigned char str_Q[] = {
	0xE7, 0x11, 0xC6, 0x9E, 0x27, 0xFB, 0x87, 0x99, 0x3E, 0x60, 0xE5, 0x16, 0xE2, 0x32, 0x9E, 0x61, 
	0x4D, 0xD6, 0x7F, 0x83, 0x00, 0xC4, 0x4B, 0x52, 0x14, 0x62, 0xA5, 0x13, 0x0C, 0xFD, 0x30, 0x1C, 
	0x88, 0x3C, 0xA2, 0x86, 0xBD, 0x9A, 0x86, 0x2C, 0x67, 0x72, 0x00, 0x9A, 0x19, 0x51, 0xE2, 0x0A, 
	0xDE, 0xEF, 0x0A, 0x83, 0xE9, 0x35, 0xCE, 0xB6, 0xFE, 0x1B, 0x7D, 0x4C, 0xC4, 0x4D, 0x52, 0x43
	};

	int res,i;
	TBarrettReduction br;
	TVlong P,Q,v_2;
	int iTstart = GetTickCountMy();

	printf("\n\n --- test_probable_prime_512 ---");

	vl_init(&P);
	vl_init(&Q);
	vl_init(&v_2);vl_set(&v_2,0,2);

	vl_set_uchar_BE(&P,str_P,sizeof(str_P));
	vl_set_uchar_BE(&Q,str_Q,sizeof(str_Q));
	//
	printf("\n P = ");
	print_vlong(&P);
	iTstart = GetTickCountMy();
	for(i = 0; i < 100; ++i){
		res = is_probable_prime(&P,1);
	}
	printf("\n is_probable_prime(100 times) = %d (%d ms)",res,GetTickCountMy()-iTstart);

	printf("\n P = ");
	print_vlong(&P);
	iTstart = GetTickCountMy();
	for(i = 0; i < 100; ++i){
		br_init(&br,&P);
		res = is_probable_prime_br(&br);
		br_delete(&br);
	}
	printf("\n is_probable_prime_br(100 times) = %d (%d ms)",res,GetTickCountMy()-iTstart);
	//
	printf("\n P(+2) = ");
	vl_add(&P,&v_2);	
	print_vlong(&P);
	iTstart = GetTickCountMy();
	for(i = 0; i < 100; ++i){
		br_init(&br,&P);
		res = is_probable_prime_br(&br);
		br_delete(&br);
	}
	printf("\n is_probable_prime_br(100 times) = %d (%d ms)",res,GetTickCountMy()-iTstart);
	//
	for(i = 0; i < 300; ++i){
		printf("\n Q = ");
		print_vlong(&Q);
		br_init(&br,&Q);
		res = is_probable_prime_br(&br);
		br_delete(&br);
		printf("\n is_probable_prime_br = %d",res);
		vl_add(&Q,&v_2);
	}
	//
	//
	vl_delete(&P);
	vl_delete(&Q);
	vl_delete(&v_2);
}


void test_raw_mul_reduction()
{
  int i;
  TVlong p,a,b,c;
  TBarrettReduction br;
  TMontExp me;
  TQuisquaterReduction qr;
  
  vl_init(&p);
  vl_init(&a);
  vl_init(&b);
  vl_init(&c);

	unsigned char str_p[] = {
	0xA2, 0xB8, 0x8B, 0x11, 0xC5, 0x09, 0x5E, 0x47, 0x30, 0xA1, 0x8C, 0x3E, 0xE5, 0x5E, 0xB1, 0xD9,
	0x37, 0x92, 0x22, 0xA7, 0x98, 0x02, 0xBD, 0x84, 0x2B, 0xBE, 0x82, 0x00, 0x33, 0x4E, 0xFE, 0xD6,
	0x71, 0x3A, 0xD2, 0x47, 0x26, 0xAD, 0x4E, 0x04, 0xF1, 0xE4, 0x98, 0x5E, 0x96, 0xB2, 0xAD, 0xE2,
	0x31, 0x77, 0x5A, 0x30, 0x97, 0x3B, 0x8A, 0xC4, 0x22, 0x04, 0xB2, 0x8C, 0x48, 0x77, 0x2F, 0xA6,
	0x60, 0xE0, 0x68, 0x15, 0x7D, 0x63, 0x52, 0xD8, 0x02, 0x36, 0x31, 0x41, 0xFC, 0xE7, 0xEE, 0x70,
	0xF5, 0x2A, 0x2F, 0xE5, 0x2B, 0x21, 0x41, 0x69, 0xD6, 0x06, 0x87, 0x48, 0x8D, 0x90, 0xE7, 0xE6,
	0x18, 0x6C, 0x47, 0xB9, 0xF2, 0xBE, 0xC1, 0x96, 0x0C, 0x2A, 0x99, 0xAA, 0x0C, 0xEA, 0xDD, 0x47,
	0x34, 0x01, 0xC5, 0x65, 0xBA, 0x00, 0x02, 0x9D, 0x0B, 0xA8, 0x9D, 0x42, 0x89, 0xD8, 0xD8, 0x81
	};
	unsigned char str_a[] = {
	0x32, 0x1A, 0x26, 0x5F, 0xE3, 0x4E, 0x5E, 0x24, 0x07, 0x5A, 0x46, 0x87, 0x7B, 0x32, 0x6C, 0x0A,
	0x58, 0xEC, 0xFB, 0x14, 0xA5, 0x5E, 0x7A, 0xA1, 0xFE, 0xA2, 0x1A, 0xFF, 0x1A, 0xCD, 0x40, 0xF4,
	0x20, 0x4B, 0x1F, 0x41, 0xDF, 0x2B, 0xCF, 0x71, 0x00, 0x56, 0x05, 0x80, 0x62, 0x60, 0x43, 0xDF,
	0xF8, 0xA1, 0x2A, 0x38, 0xF9, 0xE7, 0xD0, 0x73, 0x51, 0x92, 0x26, 0xB3, 0xC1, 0x00, 0x49, 0xC0,
	0x2F, 0x3D, 0xF6, 0x54, 0xA2, 0x01, 0x3B, 0x5B, 0x8D, 0xAF, 0x42, 0xD0, 0xBB, 0xBD, 0xE9, 0x5B,
	0x6B, 0x7C, 0x76, 0x4B, 0x89, 0x3A, 0x8B, 0x5A, 0x03, 0xFD, 0x18, 0x0F, 0x52, 0x9D, 0xEF, 0x51,
	0x56, 0x8C, 0x12, 0x38, 0xF5, 0x3E, 0x12, 0x29, 0xBF, 0x6B, 0xB0, 0x11, 0x5B, 0x23, 0x4A, 0xED,
	0x91, 0x60, 0x40, 0x32, 0x59, 0x36, 0x63, 0x2C, 0x8A, 0xF4, 0xFB, 0x7D, 0xDB, 0xE3, 0x37, 0x3D
	};
	unsigned char str_b[] = {
	 0x1C, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 
	 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC
	};
  
/*
  //id-GostR3410-2001-CryptoPro-A-ParamSet
  const unsigned char str_p[] = {
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0x97};
  
//  unsigned char str_p[] = {
//    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x31};

  unsigned char str_a[] = {
    0x7A,0x92,0x9A,0xDE,0x78,0x9B,0xB9,0xBE,0x10,0xED,0x35,0x9D,0xD3,0x9A,0x72,0xC1,
    0x1B,0x60,0x96,0x1F,0x49,0x39,0x7E,0xEE,0x1D,0x19,0xCE,0x98,0x91,0xEC,0x3B,0x28};
  unsigned char str_b[]= {
    0x08,0xE2,0xA8,0xA0,0xE6,0x51,0x47,0xD4,0xBD,0x63,0x16,0x03,0x0E,0x16,0xD1,0x9C,
    0x85,0xC9,0x7F,0x0A,0x9C,0xA2,0x67,0x12,0x2B,0x96,0xAB,0xBC,0xEA,0x7E,0x8F,0xC8};
//  unsigned char str_b[]= {
//    0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
//*/
  //
  vl_set_uchar_BE(&p,str_p,sizeof(str_p));
  vl_set_uchar_BE(&a,str_a,sizeof(str_a));
  vl_set_uchar_BE(&b,str_b,sizeof(str_b));
  
  printf("\n--- raw Test ---\n");

  printf("\n p = ");
  print_vlong(&p);

  printf("\n a = ");
  print_vlong(&a);

  printf("\n b = ");
  print_vlong(&b);
  
  //1
  int iTstart = GetTickCountMy();
  /*
  for(i=0; i<100000; i++){
    vl_modinv(&c,&a,&p);
    vl_copy(&a,&c);
  }
  printf("\n %d*vl_modinv = %d ms", i, GetTickCountMy() - iTstart);
  //*/
  //2
  br_init(&br,&p);
  //
  qr_init(&qr,&p);
  
  //3
  me_init(&me,&p);

  br_modmul(&c,&a,&b,&br);
  printf("\nbr_modmul(a*b mod p)= ");
  print_vlong(&c);
  printf("\n                   LE ");
  print_vlong_LE(&c);

  br_modmul(&c,&a,&c,&br);
  printf("\nbr_modmul(a*b*a mod p)= ");
  print_vlong(&c);

  
  vl_clear(&c);
  me_modmul(&c,&a,&b,&me);
  printf("\nme_modmul = ");
  print_vlong(&c);

  printf("\n");
  printf("\n qr.N = ");
  print_vlong(&qr.N);
  printf("\n qr.Nsh = ");
  print_vlong(&qr.Nsh);
  vl_clear(&c);
  qr_modmul(&c,&a,&b,&qr);
  printf("\nqr_modmul(a*b mod p)= ");
  print_vlong(&c);
  //
  //br_module(&c,&br);
  qr_module(&c,&qr);
  printf("\nqr_module           = ");
  print_vlong(&c);
  //
  vl_clear(&c);
  printf("\nqr_modmul(a*b*a mod p) - 1 modmul ");
  qr_modmul(&c,&a,&b,&qr);
  printf("\nqr_modmul(a*b*a mod p) - 2 modmul ");
  qr_modmul(&c,&a,&c,&qr);
  printf("\nqr_modmul(a*b*a mod p)= ");
  print_vlong(&c);
  //
  //br_module(&c,&br);
  qr_module(&c,&qr);
  printf("\nqr_module             = ");
  print_vlong(&c);

  //return;
  
  //
  vl_clear(&c);
  vl_set_uchar_BE(&a,str_a,sizeof(str_a));
  iTstart = GetTickCountMy();
  for(i=0; i<1000000; i++){
    br_modmul(&c,&a,&b,&br);
    vl_copy(&a,&c);
  }
  printf("\n %d*br_modmul = %d ms\n",i,GetTickCountMy() - iTstart);
  printf("\nbr_modmul     = ");
  print_vlong(&c);
  //

  //4
  printf("\n             a = ");
  print_vlong(&a);

  me_modexp(&c,&a,&p,&me);
  printf("\nme_modexp(a^p) = ");
  print_vlong(&c);

  printf("\nme_r2 = ");
  print_vlong(&me.r2);
  //5
  vl_clear(&c);
  iTstart = GetTickCountMy();
  for(i=0; i<1000; i++){
    me_modexp(&c,&a,&b,&me);
    vl_copy(&a,&c);
  }
  printf("\n %d*me_modexp = %d ms",i, GetTickCountMy() - iTstart); 
  
  //6
  vl_clear(&c);
  vl_set_uchar_BE(&a,str_a,sizeof(str_a));
  iTstart = GetTickCountMy();
  for(i=0; i<1000000; i++){
    me_modmul(&c,&a,&b,&me);
    vl_copy(&a,&c);
  }
  printf("\n %d*me_modmul = %d ms",i, GetTickCountMy() - iTstart);  
  printf("\nme_modmul     = ");
  print_vlong(&c);

  //7
  vl_clear(&c);
  vl_set_uchar_BE(&a,str_a,sizeof(str_a));
  iTstart = GetTickCountMy();
  for(i=0; i<1000000; i++){
    qr_modmul(&c,&b,&a,&qr);
    vl_copy(&a,&c);
  }
  printf("\n %d*qr_modmul = %d ms",i, GetTickCountMy() - iTstart);  
  printf("\nqr_modmul     = ");
  print_vlong(&c);
  qr_module(&c,&qr);
  printf("\nqr_module     = ");
  print_vlong(&c);
  
  //
  vl_delete(&p);
  vl_delete(&a);
  vl_delete(&b);
  vl_delete(&c);
  br_delete(&br);
  me_delete(&me);
  qr_delete(&qr);
  //return 0;
}

// ------------------------------------------------------------------------

void print_hex(const unsigned char *strHex, unsigned int uLenHex)
{
  char str[1024];
  str[0] = 0;
  print_hex_str(strHex,uLenHex,str);
  printf("%s",str);
};

void print_hex_str(const unsigned char *strHex, unsigned int uLenHex, char *strRes)
{
  unsigned int i;
#ifdef __BORLANDC__

  typedef WINUSERAPI int (WINAPIV *TwsprintfA)(LPSTR, LPCSTR, ...);
  TwsprintfA pwsprintfA;
  pwsprintfA = (TwsprintfA)::GetProcAddress(::GetModuleHandle("user32"),"wsprintfA");

  if(pwsprintfA)
#endif
  {
    for(i=0;i<uLenHex;i++)
    {
      #ifdef __BORLANDC__
        pwsprintfA(&strRes[i*2],"%02X",(unsigned char)strHex[i]);
      #else
        //wsprintfA(&strRes[i*2],"%02X",(unsigned char)strHex[i]);
        sprintf(&strRes[i*2],"%02X",(unsigned char)strHex[i]);
      #endif
      strRes[i*2+2] = 0;
    }
  };
};

void print_vlong(PTVlong pvl){
  unsigned char strx[1024];
  char str[1024];
  unsigned int i;
  str[0] = 0x30;
  str[1] = 0;
  i = sizeof(strx);
  if(vl_get_uchar_BE(strx, &i, pvl) == 1){
    print_hex_str(strx,i,str);
    printf("%s",(char*)str);
  }

}

void print_vlong_LE(PTVlong pvl){
  unsigned char strx[1024];
  char str[1024];
  unsigned int i;
  str[0] = 0x30;
  str[1] = 0;
  i = sizeof(strx);
  if(vl_get_uchar_LE(strx, &i, pvl) == 1){
    print_hex_str(strx,i,str);
    printf("%s",(char*)str);
  }

}


//------ rnd emulate -------

static
int my_rand(int *pnext){
  int hi, lo, x;
  // Can't be initialized with 0, so use another value.
  if (*pnext == 0)
    *pnext = 123459876;
  hi = *pnext / 127773;
  lo = *pnext % 127773;
  x = 16807 * lo - 2836 * hi;
  if (x < 0)
    x += 0x7fffffff;
  *pnext = x;
  return (x & 0x7fffffff);
}

static int rnd_seed = 0;

RngError rngInit(RngMode mode, uint8_t seed[40]) {
  rnd_seed ^= (int)(GetTickCountMy()*GetTickCountMy());
  //rnd_seed = 0x39232B61;
  //rnd_seed = 0x09D4B790;
  //rnd_seed = 0x9624AE24;
  //rnd_seed = 0xB164BE40;
  //rnd_seed = 0x5BE888A4;
  printf("\nrngInit:seed = 0x%08X\n",(unsigned int)rnd_seed);
  return NO_RNG_ERROR;
}

RngError rngGet(uint8_t rng[32]) {
  int i;
  RngError ret = NO_RNG_ERROR;
  if(rng)
    for(i = 0; i<32; i++){
      rng[i] = (uint8_t)my_rand(&rnd_seed);
    }
  else
	  ret = RNG_FAILED;
  //
  return ret;
}


#ifdef __GNUC__
int GetTickCountMy(){//time in ms
  struct timespec tp;
  
  clock_gettime(1, &tp);
  
  return (tp.tv_sec*1000) + (tp.tv_nsec/1000000);
}
#endif

#ifdef WIN32
static LARGE_INTEGER frequency = { 0 };
int GetTickCountMy() {//time in ms
  LARGE_INTEGER start;
  //
  QueryPerformanceCounter(&start);
  //
  if (frequency.QuadPart == 0)
    QueryPerformanceFrequency(&frequency);
  //
  float fstart_ms = start.QuadPart * 1000.0f / frequency.QuadPart;
  //
  return (int)fstart_ms;
}
#endif//WIN32
